{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction tgintegration is a Python library that helps you test your bots and automate routine tasks on Telegram Messenger . It does so by logging in as a user or interacting in your name using the popular Pyrogram library and mtproto . See it in action Your browser does not support the video tag. The Testing Pyramid When writing software, it is almost always a good idea to have a number of tests for your code (this varies by the complexity of your project). What kinds of tests should be written typically follows the so-called \"testing pyramid\" . This guideline recommends to have a test suite consisting of a large base of unit tests , a fair number of integration tests , and only very few end-to-end (E2E) or manual tests . In this classification, tgintegration lies in the center and should be seen as a supplement to unit tests that cover the core logic of your bot. By their nature, integration tests are slower since they interact with multiple systems over the network instead of everything happening on the same machine. The same is true for tgintegration , which reaches out to the Telegram servers to automate an interaction between two conversation partners.","title":"Overview"},{"location":"#introduction","text":"tgintegration is a Python library that helps you test your bots and automate routine tasks on Telegram Messenger . It does so by logging in as a user or interacting in your name using the popular Pyrogram library and mtproto .","title":"Introduction"},{"location":"#see-it-in-action","text":"Your browser does not support the video tag.","title":"See it in action"},{"location":"#the-testing-pyramid","text":"When writing software, it is almost always a good idea to have a number of tests for your code (this varies by the complexity of your project). What kinds of tests should be written typically follows the so-called \"testing pyramid\" . This guideline recommends to have a test suite consisting of a large base of unit tests , a fair number of integration tests , and only very few end-to-end (E2E) or manual tests . In this classification, tgintegration lies in the center and should be seen as a supplement to unit tests that cover the core logic of your bot. By their nature, integration tests are slower since they interact with multiple systems over the network instead of everything happening on the same machine. The same is true for tgintegration , which reaches out to the Telegram servers to automate an interaction between two conversation partners.","title":"The Testing Pyramid"},{"location":"_TODO/","text":"TgIntegration Documentation TODOs Guide on how to create a CI pipeline with tgintegration Add setup instructions on the library itself (for contributors)","title":"TgIntegration Documentation TODOs"},{"location":"_TODO/#tgintegration-documentation-todos","text":"Guide on how to create a CI pipeline with tgintegration Add setup instructions on the library itself (for contributors)","title":"TgIntegration Documentation TODOs"},{"location":"api-mkapi/","text":"mkapi MODULE TGINTEGRATION . BOTCONTROLLER Entry point to tgintegration features. Classes BotController \u2014 This class is the entry point for all interactions with either regular bots or userbots in TgIntegration . It expects a Pyrogram Client (typically a user client ) that serves as the controll ing account for a specific peer - which can be seen as the \"bot under test\" or \"conversation partner\". In addition, the controller holds a number of settings to control the timeouts for all these interactions. class tgintegration.botcontroller . BotController ( client , peer , max_wait=20.0 , wait_consecutive=2.0 , raise_no_response=True , global_action_delay=0.8 ) This class is the entry point for all interactions with either regular bots or userbots in TgIntegration . It expects a Pyrogram Client (typically a user client ) that serves as the controll ing account for a specific peer - which can be seen as the \"bot under test\" or \"conversation partner\". In addition, the controller holds a number of settings to control the timeouts for all these interactions. Methods add_handler_transient ( handler ) (NoneType) \u2014 Registers a one-time/ad-hoc Pyrogram Handler that is only valid during the context manager body. clear_chat ( ) \u2014 Deletes all messages in the conversation with the assigned peer . initialize ( start_client ) \u2014 Fetches and caches information about the given peer and optionally starts the assigned client . This method will automatically be called when coroutines of this class are invoked, but you can call it manually to override defaults (namely whether to start_client ). query_inline ( query , latitude , longitude , limit ) ( InlineResultContainer ) \u2014 Requests inline results from the peer (which needs to be a bot). send_command ( command , args , peer , add_bot_name ) (Message) \u2014 Send a slash-command with corresponding parameters. method initialize ( start_client=True ) Fetches and caches information about the given peer and optionally starts the assigned client . This method will automatically be called when coroutines of this class are invoked, but you can call it manually to override defaults (namely whether to start_client ). Parameters start_client (bool, optional) \u2014 Set to False if the client should not be started as part of initialization. Note It is unlikely that you will need to call this manually. method clear_chat ( ) Deletes all messages in the conversation with the assigned peer . Warning Be careful as this will completely drop your mutual message history. method add_handler_transient ( handler ) Registers a one-time/ad-hoc Pyrogram Handler that is only valid during the context manager body. Parameters handler (Handler) \u2014 A Pyrogram Handler (typically a MessageHandler ). Yields (NoneType) None Examples async def some_callback ( client , message ): print ( message ) async def main (): async with controller . add_handler_transient ( MessageHandler ( some_callback , filters . text )): await controller . send_command ( \"start\" ) await asyncio . sleep ( 3 ) # Wait 3 seconds for a reply method collect ( filters=None , count=None , peer=None , max_wait=15 , wait_consecutive=None , raise_=None ) \u2192 abstractasynccontextmanager of Response method send_command ( command , args=None , peer=None , add_bot_name=True ) \u2192 Message Send a slash-command with corresponding parameters. method query_inline ( query , latitude=None , longitude=None , limit=200 ) Requests inline results from the peer (which needs to be a bot). Parameters query (str) \u2014 The query text. latitude (float, optional) \u2014 Latitude of a geo point. longitude (float, optional) \u2014 Longitude of a geo point. limit (int, optional) \u2014 When result pages get iterated automatically, specifies the maximum number of results to return from the bot. Returns ( InlineResultContainer ) A container for convenient access to the inline results.","title":"mkapi"},{"location":"api-mkapi/#mkapi","text":"MODULE","title":"mkapi"},{"location":"api-mkapi/#tgintegrationbotcontroller","text":"Entry point to tgintegration features. Classes BotController \u2014 This class is the entry point for all interactions with either regular bots or userbots in TgIntegration . It expects a Pyrogram Client (typically a user client ) that serves as the controll ing account for a specific peer - which can be seen as the \"bot under test\" or \"conversation partner\". In addition, the controller holds a number of settings to control the timeouts for all these interactions. class","title":"tgintegration.botcontroller"},{"location":"api-mkapi/#tgintegrationbotcontrollerbotcontroller","text":"This class is the entry point for all interactions with either regular bots or userbots in TgIntegration . It expects a Pyrogram Client (typically a user client ) that serves as the controll ing account for a specific peer - which can be seen as the \"bot under test\" or \"conversation partner\". In addition, the controller holds a number of settings to control the timeouts for all these interactions. Methods add_handler_transient ( handler ) (NoneType) \u2014 Registers a one-time/ad-hoc Pyrogram Handler that is only valid during the context manager body. clear_chat ( ) \u2014 Deletes all messages in the conversation with the assigned peer . initialize ( start_client ) \u2014 Fetches and caches information about the given peer and optionally starts the assigned client . This method will automatically be called when coroutines of this class are invoked, but you can call it manually to override defaults (namely whether to start_client ). query_inline ( query , latitude , longitude , limit ) ( InlineResultContainer ) \u2014 Requests inline results from the peer (which needs to be a bot). send_command ( command , args , peer , add_bot_name ) (Message) \u2014 Send a slash-command with corresponding parameters. method initialize ( start_client=True ) Fetches and caches information about the given peer and optionally starts the assigned client . This method will automatically be called when coroutines of this class are invoked, but you can call it manually to override defaults (namely whether to start_client ). Parameters start_client (bool, optional) \u2014 Set to False if the client should not be started as part of initialization. Note It is unlikely that you will need to call this manually. method clear_chat ( ) Deletes all messages in the conversation with the assigned peer . Warning Be careful as this will completely drop your mutual message history. method add_handler_transient ( handler ) Registers a one-time/ad-hoc Pyrogram Handler that is only valid during the context manager body. Parameters handler (Handler) \u2014 A Pyrogram Handler (typically a MessageHandler ). Yields (NoneType) None Examples async def some_callback ( client , message ): print ( message ) async def main (): async with controller . add_handler_transient ( MessageHandler ( some_callback , filters . text )): await controller . send_command ( \"start\" ) await asyncio . sleep ( 3 ) # Wait 3 seconds for a reply method collect ( filters=None , count=None , peer=None , max_wait=15 , wait_consecutive=None , raise_=None ) \u2192 abstractasynccontextmanager of Response method send_command ( command , args=None , peer=None , add_bot_name=True ) \u2192 Message Send a slash-command with corresponding parameters. method query_inline ( query , latitude=None , longitude=None , limit=200 ) Requests inline results from the peer (which needs to be a bot). Parameters query (str) \u2014 The query text. latitude (float, optional) \u2014 Latitude of a geo point. longitude (float, optional) \u2014 Longitude of a geo point. limit (int, optional) \u2014 When result pages get iterated automatically, specifies the maximum number of results to return from the bot. Returns ( InlineResultContainer ) A container for convenient access to the inline results.","title":"tgintegration.botcontroller.BotController"},{"location":"api-mkdocstrings/","text":"mkdocstrings Entry point to {{tgi}} features. BotController This class is the entry point for all interactions with either regular bots or userbots in TgIntegration . It expects a Pyrogram Client (typically a user client ) that serves as the controll ing account for a specific peer - which can be seen as the \"bot under test\" or \"conversation partner\". In addition, the controller holds a number of settings to control the timeouts for all these interactions. __init__ ( self , client , peer , * , max_wait = 20.0 , wait_consecutive = 2.0 , raise_no_response = True , global_action_delay = 0.8 ) special Creates a new BotController . Parameters: Name Type Description Default client Client A Pyrogram user client that acts as the controll ing account. required peer Union[int, str] The bot under test or conversation partner. required max_wait Union[int, float] Maximum time in seconds for the peer to produce the expected response. 20.0 wait_consecutive Union[int, float] Additional time in seconds to wait for additional messages upon receiving a response (even when max_wait is exceeded). 2.0 raise_no_response bool Whether to raise an exception on timeout/invalid response or to log silently. True global_action_delay Union[int, float] The time to wait in between collect calls. 0.8 Source code in tgintegration/botcontroller.py def __init__ ( self , client : Client , peer : Union [ int , str ], * , max_wait : Union [ int , float ] = 20.0 , wait_consecutive : Optional [ Union [ int , float ]] = 2.0 , raise_no_response : bool = True , global_action_delay : Union [ int , float ] = 0.8 , ): \"\"\" Creates a new `BotController`. Args: client: A Pyrogram user client that acts as the controll*ing* account. peer: The bot under test or conversation partner. max_wait: Maximum time in seconds for the `peer` to produce the expected response. wait_consecutive: Additional time in seconds to wait for _additional_ messages upon receiving a response (even when `max_wait` is exceeded). raise_no_response: Whether to raise an exception on timeout/invalid response or to log silently. global_action_delay: The time to wait in between `collect` calls. \"\"\" self . client = client self . peer = peer self . max_wait_response = max_wait self . min_wait_consecutive = wait_consecutive self . raise_no_response = raise_no_response self . global_action_delay = global_action_delay self . _input_peer : Optional [ InputPeerUser ] = None self . peer_user : Optional [ User ] = None self . peer_id : Optional [ int ] = None self . command_list : List [ BotCommand ] = [] self . _last_response_ts : Optional [ time ] = None self . logger = logging . getLogger ( self . __class__ . __name__ ) add_handler_transient ( self , handler ) Registers a one-time/ad-hoc Pyrogram Handler that is only valid during the context manager body. Parameters: Name Type Description Default handler Handler A Pyrogram Handler (typically a MessageHandler ). required Yields None Examples: async def some_callback ( client , message ): print ( message ) async def main (): async with controller . add_handler_transient ( MessageHandler ( some_callback , filters . text )): await controller . send_command ( \"start\" ) await asyncio . sleep ( 3 ) # Wait 3 seconds for a reply Source code in tgintegration/botcontroller.py @asynccontextmanager async def add_handler_transient ( self , handler : Handler ) -> AsyncContextManager [ None ]: \"\"\" Registers a one-time/ad-hoc Pyrogram `Handler` that is only valid during the context manager body. Args: handler: A Pyrogram `Handler` (typically a `MessageHandler`). Yields: `None` Examples: ``` python async def some_callback(client, message): print(message) async def main(): async with controller.add_handler_transient(MessageHandler(some_callback, filters.text)): await controller.send_command(\"start\") await asyncio.sleep(3) # Wait 3 seconds for a reply ``` \"\"\" async with add_handler_transient ( self . client , handler ): yield clear_chat ( self ) async Deletes all messages in the conversation with the assigned peer . Warning Be careful as this will completely drop your mutual message history. Source code in tgintegration/botcontroller.py async def clear_chat ( self ) -> None : \"\"\" Deletes all messages in the conversation with the assigned `peer`. !!! warning Be careful as this will completely drop your mutual message history. \"\"\" await self . _ensure_preconditions () await self . client . send ( DeleteHistory ( peer = self . _input_peer , max_id = 0 , just_clear = False ) ) collect ( self , filters = None , count = None , * , peer = None , max_wait = 15 , wait_consecutive = None , raise_ = None ) Parameters: Name Type Description Default filters Filter None count int None peer Union[int, str] None max_wait Union[int, float] 15 wait_consecutive Union[int, float] None raise_ Optional[bool] None Returns: Type Description AbstractAsyncContextManager[tgintegration.containers.responses.Response] Source code in tgintegration/botcontroller.py @asynccontextmanager async def collect ( self , filters : Filter = None , count : int = None , * , peer : Union [ int , str ] = None , max_wait : Union [ int , float ] = 15 , wait_consecutive : Optional [ Union [ int , float ]] = None , raise_ : Optional [ bool ] = None , ) -> AsyncContextManager [ Response ]: \"\"\" Args: filters (): count (): peer (): max_wait (): wait_consecutive (): raise_ (): Returns: \"\"\" await self . _ensure_preconditions () await self . _wait_if_necessary () async with collect ( self , self . _merge_default_filters ( filters , peer ), expectation = Expectation ( min_messages = count or NotSet , max_messages = count or NotSet ), timeouts = TimeoutSettings ( max_wait = max_wait , wait_consecutive = wait_consecutive , raise_on_timeout = raise_ if raise_ is not None else self . raise_no_response , ), ) as response : yield response self . _last_response_ts = response . last_message_timestamp initialize ( self , start_client = True ) async Fetches and caches information about the given peer and optionally starts the assigned client . This method will automatically be called when coroutines of this class are invoked, but you can call it manually to override defaults (namely whether to start_client ). Parameters: Name Type Description Default start_client bool Set to False if the client should not be started as part of initialization. True Note It is unlikely that you will need to call this manually. Source code in tgintegration/botcontroller.py async def initialize ( self , start_client : bool = True ) -> None : # noinspection PyUnresolvedReferences \"\"\" Fetches and caches information about the given `peer` and optionally starts the assigned `client`. This method will automatically be called when coroutines of this class are invoked, but you can call it manually to override defaults (namely whether to `start_client`). Args: start_client: Set to `False` if the client should not be started as part of initialization. !!! note It is unlikely that you will need to call this manually. \"\"\" if start_client and not self . client . is_connected : await self . client . start () self . _input_peer = await self . client . resolve_peer ( self . peer ) self . peer_user = await self . client . get_users ( self . peer ) self . peer_id = self . peer_user . id if self . peer_user . is_bot : self . command_list = await self . _get_command_list () query_inline ( self , query , latitude = None , longitude = None , limit = 200 ) async Requests inline results from the peer (which needs to be a bot). Parameters: Name Type Description Default query str The query text. required latitude float Latitude of a geo point. None longitude float Longitude of a geo point. None limit int When result pages get iterated automatically, specifies the maximum number of results to return from the bot. 200 Returns: Type Description InlineResultContainer A container for convenient access to the inline results. Source code in tgintegration/botcontroller.py async def query_inline ( self , query : str , latitude : float = None , longitude : float = None , limit : int = 200 , ) -> InlineResultContainer : \"\"\" Requests inline results from the `peer` (which needs to be a bot). Args: query: The query text. latitude: Latitude of a geo point. longitude: Longitude of a geo point. limit: When result pages get iterated automatically, specifies the maximum number of results to return from the bot. Returns: A container for convenient access to the inline results. \"\"\" await self . _ensure_preconditions ( bots_only = True ) if limit <= 0 : raise ValueError ( \"Cannot get 0 or less results.\" ) start_offset = \"\" first_batch : BotResults = await self . client . get_inline_bot_results ( self . peer_id , query , offset = start_offset , latitude = latitude , longitude = longitude , ) gallery = first_batch . gallery switch_pm = first_batch . switch_pm users = first_batch . users results = [ x async for x in self . _iter_bot_results ( first_batch , query , latitude = latitude , longitude = longitude , limit = limit , current_offset = start_offset , ) ] return InlineResultContainer ( self , query , latitude = latitude , longitude = longitude , results = results , gallery = gallery , switch_pm = switch_pm , users = users , ) send_command ( self , command , args = None , peer = None , add_bot_name = True ) async Send a slash-command with corresponding parameters. Source code in tgintegration/botcontroller.py async def send_command ( self , command : str , args : List [ str ] = None , peer : Union [ int , str ] = None , add_bot_name : bool = True , ) -> Message : \"\"\" Send a slash-command with corresponding parameters. \"\"\" text = \"/\" + command . lstrip ( \"/\" ) if add_bot_name and self . peer_user . username : text += f \"@ { self . peer_user . username } \" if args : text += \" \" text += \" \" . join ( args ) return await self . client . send_message ( peer or self . peer_id , text )","title":"mkdocstrings"},{"location":"api-mkdocstrings/#mkdocstrings","text":"","title":"mkdocstrings"},{"location":"api-mkdocstrings/#tgintegration.botcontroller","text":"Entry point to {{tgi}} features.","title":"tgintegration.botcontroller"},{"location":"api-mkdocstrings/#tgintegration.botcontroller.BotController","text":"This class is the entry point for all interactions with either regular bots or userbots in TgIntegration . It expects a Pyrogram Client (typically a user client ) that serves as the controll ing account for a specific peer - which can be seen as the \"bot under test\" or \"conversation partner\". In addition, the controller holds a number of settings to control the timeouts for all these interactions.","title":"BotController"},{"location":"api-mkdocstrings/#tgintegration.botcontroller.BotController.__init__","text":"Creates a new BotController . Parameters: Name Type Description Default client Client A Pyrogram user client that acts as the controll ing account. required peer Union[int, str] The bot under test or conversation partner. required max_wait Union[int, float] Maximum time in seconds for the peer to produce the expected response. 20.0 wait_consecutive Union[int, float] Additional time in seconds to wait for additional messages upon receiving a response (even when max_wait is exceeded). 2.0 raise_no_response bool Whether to raise an exception on timeout/invalid response or to log silently. True global_action_delay Union[int, float] The time to wait in between collect calls. 0.8 Source code in tgintegration/botcontroller.py def __init__ ( self , client : Client , peer : Union [ int , str ], * , max_wait : Union [ int , float ] = 20.0 , wait_consecutive : Optional [ Union [ int , float ]] = 2.0 , raise_no_response : bool = True , global_action_delay : Union [ int , float ] = 0.8 , ): \"\"\" Creates a new `BotController`. Args: client: A Pyrogram user client that acts as the controll*ing* account. peer: The bot under test or conversation partner. max_wait: Maximum time in seconds for the `peer` to produce the expected response. wait_consecutive: Additional time in seconds to wait for _additional_ messages upon receiving a response (even when `max_wait` is exceeded). raise_no_response: Whether to raise an exception on timeout/invalid response or to log silently. global_action_delay: The time to wait in between `collect` calls. \"\"\" self . client = client self . peer = peer self . max_wait_response = max_wait self . min_wait_consecutive = wait_consecutive self . raise_no_response = raise_no_response self . global_action_delay = global_action_delay self . _input_peer : Optional [ InputPeerUser ] = None self . peer_user : Optional [ User ] = None self . peer_id : Optional [ int ] = None self . command_list : List [ BotCommand ] = [] self . _last_response_ts : Optional [ time ] = None self . logger = logging . getLogger ( self . __class__ . __name__ )","title":"__init__()"},{"location":"api-mkdocstrings/#tgintegration.botcontroller.BotController.add_handler_transient","text":"Registers a one-time/ad-hoc Pyrogram Handler that is only valid during the context manager body. Parameters: Name Type Description Default handler Handler A Pyrogram Handler (typically a MessageHandler ). required Yields None Examples: async def some_callback ( client , message ): print ( message ) async def main (): async with controller . add_handler_transient ( MessageHandler ( some_callback , filters . text )): await controller . send_command ( \"start\" ) await asyncio . sleep ( 3 ) # Wait 3 seconds for a reply Source code in tgintegration/botcontroller.py @asynccontextmanager async def add_handler_transient ( self , handler : Handler ) -> AsyncContextManager [ None ]: \"\"\" Registers a one-time/ad-hoc Pyrogram `Handler` that is only valid during the context manager body. Args: handler: A Pyrogram `Handler` (typically a `MessageHandler`). Yields: `None` Examples: ``` python async def some_callback(client, message): print(message) async def main(): async with controller.add_handler_transient(MessageHandler(some_callback, filters.text)): await controller.send_command(\"start\") await asyncio.sleep(3) # Wait 3 seconds for a reply ``` \"\"\" async with add_handler_transient ( self . client , handler ): yield","title":"add_handler_transient()"},{"location":"api-mkdocstrings/#tgintegration.botcontroller.BotController.clear_chat","text":"Deletes all messages in the conversation with the assigned peer . Warning Be careful as this will completely drop your mutual message history. Source code in tgintegration/botcontroller.py async def clear_chat ( self ) -> None : \"\"\" Deletes all messages in the conversation with the assigned `peer`. !!! warning Be careful as this will completely drop your mutual message history. \"\"\" await self . _ensure_preconditions () await self . client . send ( DeleteHistory ( peer = self . _input_peer , max_id = 0 , just_clear = False ) )","title":"clear_chat()"},{"location":"api-mkdocstrings/#tgintegration.botcontroller.BotController.collect","text":"Parameters: Name Type Description Default filters Filter None count int None peer Union[int, str] None max_wait Union[int, float] 15 wait_consecutive Union[int, float] None raise_ Optional[bool] None Returns: Type Description AbstractAsyncContextManager[tgintegration.containers.responses.Response] Source code in tgintegration/botcontroller.py @asynccontextmanager async def collect ( self , filters : Filter = None , count : int = None , * , peer : Union [ int , str ] = None , max_wait : Union [ int , float ] = 15 , wait_consecutive : Optional [ Union [ int , float ]] = None , raise_ : Optional [ bool ] = None , ) -> AsyncContextManager [ Response ]: \"\"\" Args: filters (): count (): peer (): max_wait (): wait_consecutive (): raise_ (): Returns: \"\"\" await self . _ensure_preconditions () await self . _wait_if_necessary () async with collect ( self , self . _merge_default_filters ( filters , peer ), expectation = Expectation ( min_messages = count or NotSet , max_messages = count or NotSet ), timeouts = TimeoutSettings ( max_wait = max_wait , wait_consecutive = wait_consecutive , raise_on_timeout = raise_ if raise_ is not None else self . raise_no_response , ), ) as response : yield response self . _last_response_ts = response . last_message_timestamp","title":"collect()"},{"location":"api-mkdocstrings/#tgintegration.botcontroller.BotController.initialize","text":"Fetches and caches information about the given peer and optionally starts the assigned client . This method will automatically be called when coroutines of this class are invoked, but you can call it manually to override defaults (namely whether to start_client ). Parameters: Name Type Description Default start_client bool Set to False if the client should not be started as part of initialization. True Note It is unlikely that you will need to call this manually. Source code in tgintegration/botcontroller.py async def initialize ( self , start_client : bool = True ) -> None : # noinspection PyUnresolvedReferences \"\"\" Fetches and caches information about the given `peer` and optionally starts the assigned `client`. This method will automatically be called when coroutines of this class are invoked, but you can call it manually to override defaults (namely whether to `start_client`). Args: start_client: Set to `False` if the client should not be started as part of initialization. !!! note It is unlikely that you will need to call this manually. \"\"\" if start_client and not self . client . is_connected : await self . client . start () self . _input_peer = await self . client . resolve_peer ( self . peer ) self . peer_user = await self . client . get_users ( self . peer ) self . peer_id = self . peer_user . id if self . peer_user . is_bot : self . command_list = await self . _get_command_list ()","title":"initialize()"},{"location":"api-mkdocstrings/#tgintegration.botcontroller.BotController.query_inline","text":"Requests inline results from the peer (which needs to be a bot). Parameters: Name Type Description Default query str The query text. required latitude float Latitude of a geo point. None longitude float Longitude of a geo point. None limit int When result pages get iterated automatically, specifies the maximum number of results to return from the bot. 200 Returns: Type Description InlineResultContainer A container for convenient access to the inline results. Source code in tgintegration/botcontroller.py async def query_inline ( self , query : str , latitude : float = None , longitude : float = None , limit : int = 200 , ) -> InlineResultContainer : \"\"\" Requests inline results from the `peer` (which needs to be a bot). Args: query: The query text. latitude: Latitude of a geo point. longitude: Longitude of a geo point. limit: When result pages get iterated automatically, specifies the maximum number of results to return from the bot. Returns: A container for convenient access to the inline results. \"\"\" await self . _ensure_preconditions ( bots_only = True ) if limit <= 0 : raise ValueError ( \"Cannot get 0 or less results.\" ) start_offset = \"\" first_batch : BotResults = await self . client . get_inline_bot_results ( self . peer_id , query , offset = start_offset , latitude = latitude , longitude = longitude , ) gallery = first_batch . gallery switch_pm = first_batch . switch_pm users = first_batch . users results = [ x async for x in self . _iter_bot_results ( first_batch , query , latitude = latitude , longitude = longitude , limit = limit , current_offset = start_offset , ) ] return InlineResultContainer ( self , query , latitude = latitude , longitude = longitude , results = results , gallery = gallery , switch_pm = switch_pm , users = users , )","title":"query_inline()"},{"location":"api-mkdocstrings/#tgintegration.botcontroller.BotController.send_command","text":"Send a slash-command with corresponding parameters. Source code in tgintegration/botcontroller.py async def send_command ( self , command : str , args : List [ str ] = None , peer : Union [ int , str ] = None , add_bot_name : bool = True , ) -> Message : \"\"\" Send a slash-command with corresponding parameters. \"\"\" text = \"/\" + command . lstrip ( \"/\" ) if add_bot_name and self . peer_user . username : text += f \"@ { self . peer_user . username } \" if args : text += \" \" text += \" \" . join ( args ) return await self . client . send_message ( peer or self . peer_id , text )","title":"send_command()"},{"location":"contributing/","text":"","title":"Contributing"},{"location":"getting-started/","text":"Getting Started You can follow along by running the example ( README ) Setup Suppose we want to write integration tests for @BotListBot by sending it a couple of messages and checking that it responds the way it should. After configuring a Pyrogram user client , let's start by creating a BotController : from tgintegration import BotController controller = BotController ( peer = \"@BotListBot\" , # The bot under test is https://t.me/BotListBot \ud83e\udd16 client = client , # This assumes you already have a Pyrogram user client available max_wait = 8 , # Maximum timeout for responses (optional) wait_consecutive = 2 , # Minimum time to wait for more/consecutive messages (optional) raise_no_response = True , # Raise `InvalidResponseError` when no response is received (defaults to True) global_action_delay = 2.5 # Choosing a rather high delay so we can observe what's happening (optional) ) await controller . clear_chat () # Start with a blank screen (\u26a0\ufe0f) Now, let's send /start to the bot and wait until exactly three messages have been received by using the asynchronous collect context manager: async with controller . collect ( count = 3 ) as response : await controller . send_command ( \"start\" ) assert response . num_messages == 3 # Three messages received, bundled under a `Response` object assert response . messages [ 0 ] . sticker # The first message is a sticker The result should look like this: Examining the buttons in the response... # Get first (and only) inline keyboard from the replies inline_keyboard = response . inline_keyboards [ 0 ] # Three buttons in the first row assert len ( inline_keyboard . rows [ 0 ]) == 3 We can also press the inline keyboard buttons, for example based on a regular expression: examples = await inline_keyboard . click ( pattern = r \".*Examples\" ) As the bot edits the message, .click() automatically listens for \"message edited\" updates and returns the new state as another Response . assert \"Examples for contributing to the BotList\" in examples . full_text Error handling So what happens when we send an invalid query or the peer fails to respond? The following instruction will raise an InvalidResponseError after controller.max_wait seconds. This is because we passed raise_no_response=True during controller initialization. try : async with controller . collect (): await controller . send_command ( \"ayylmao\" ) except InvalidResponseError : pass # OK Let's explicitly set raise_ to False so that no exception occurs: async with controller . collect ( raise_ = False ) as response : await client . send_message ( controller . peer_id , \"Henlo Fren\" ) In this case, tgintegration will simply emit a warning, but you can still assert that no response has been received by using the is_empty property: assert response . is_empty","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"You can follow along by running the example ( README )","title":"Getting Started"},{"location":"getting-started/#setup","text":"Suppose we want to write integration tests for @BotListBot by sending it a couple of messages and checking that it responds the way it should. After configuring a Pyrogram user client , let's start by creating a BotController : from tgintegration import BotController controller = BotController ( peer = \"@BotListBot\" , # The bot under test is https://t.me/BotListBot \ud83e\udd16 client = client , # This assumes you already have a Pyrogram user client available max_wait = 8 , # Maximum timeout for responses (optional) wait_consecutive = 2 , # Minimum time to wait for more/consecutive messages (optional) raise_no_response = True , # Raise `InvalidResponseError` when no response is received (defaults to True) global_action_delay = 2.5 # Choosing a rather high delay so we can observe what's happening (optional) ) await controller . clear_chat () # Start with a blank screen (\u26a0\ufe0f) Now, let's send /start to the bot and wait until exactly three messages have been received by using the asynchronous collect context manager: async with controller . collect ( count = 3 ) as response : await controller . send_command ( \"start\" ) assert response . num_messages == 3 # Three messages received, bundled under a `Response` object assert response . messages [ 0 ] . sticker # The first message is a sticker The result should look like this: Examining the buttons in the response... # Get first (and only) inline keyboard from the replies inline_keyboard = response . inline_keyboards [ 0 ] # Three buttons in the first row assert len ( inline_keyboard . rows [ 0 ]) == 3 We can also press the inline keyboard buttons, for example based on a regular expression: examples = await inline_keyboard . click ( pattern = r \".*Examples\" ) As the bot edits the message, .click() automatically listens for \"message edited\" updates and returns the new state as another Response . assert \"Examples for contributing to the BotList\" in examples . full_text","title":"Setup"},{"location":"getting-started/#error-handling","text":"So what happens when we send an invalid query or the peer fails to respond? The following instruction will raise an InvalidResponseError after controller.max_wait seconds. This is because we passed raise_no_response=True during controller initialization. try : async with controller . collect (): await controller . send_command ( \"ayylmao\" ) except InvalidResponseError : pass # OK Let's explicitly set raise_ to False so that no exception occurs: async with controller . collect ( raise_ = False ) as response : await client . send_message ( controller . peer_id , \"Henlo Fren\" ) In this case, tgintegration will simply emit a warning, but you can still assert that no response has been received by using the is_empty property: assert response . is_empty","title":"Error handling"},{"location":"installation/","text":"Installation All hail pip! $ pip install tgintegration --upgrade Feeling adventurous? For bleeding edge, install the master branch: pip install git+https://github.com/JosXa/tgintegration.git","title":"Installation"},{"location":"installation/#installation","text":"All hail pip! $ pip install tgintegration --upgrade Feeling adventurous? For bleeding edge, install the master branch: pip install git+https://github.com/JosXa/tgintegration.git","title":"Installation"},{"location":"prerequisites/","text":"Prerequisites Same as Pyrogram : Python 3.7 or higher. A Telegram API key . A user session (seeing things happen in your own account is great for getting started)","title":"Prerequisites"},{"location":"prerequisites/#prerequisites","text":"Same as Pyrogram : Python 3.7 or higher. A Telegram API key . A user session (seeing things happen in your own account is great for getting started)","title":"Prerequisites"},{"location":"setup/","text":"Prerequisites Same as Pyrogram : Python 3.7 or higher. A Telegram API key . A user session (seeing things happen in your own account is great for getting started) Installation All hail pip! $ pip install tgintegration --upgrade Feeling adventurous? For bleeding edge, install the master branch: pip install git+https://github.com/JosXa/tgintegration.git","title":"Setup"},{"location":"setup/#prerequisites","text":"Same as Pyrogram : Python 3.7 or higher. A Telegram API key . A user session (seeing things happen in your own account is great for getting started)","title":"Prerequisites"},{"location":"setup/#installation","text":"All hail pip! $ pip install tgintegration --upgrade Feeling adventurous? For bleeding edge, install the master branch: pip install git+https://github.com/JosXa/tgintegration.git","title":"Installation"},{"location":"api/tgintegration.botcontroller/","text":"module tgintegration . botcontroller </> Entry point to tgintegration features. Classes BotController \u2014 This class is the entry point for all interactions with either regular bots or userbots in TgIntegration . It expects a Pyrogram Client (typically a user client ) that serves as the controll ing account for a specific peer - which can be seen as the \"bot under test\" or \"conversation partner\". In addition, the controller holds a number of settings to control the timeouts for all these interactions. </> class tgintegration.botcontroller . BotController ( client , peer , max_wait=20.0 , wait_consecutive=2.0 , raise_no_response=True , global_action_delay=0.8 ) </> This class is the entry point for all interactions with either regular bots or userbots in TgIntegration . It expects a Pyrogram Client (typically a user client ) that serves as the controll ing account for a specific peer - which can be seen as the \"bot under test\" or \"conversation partner\". In addition, the controller holds a number of settings to control the timeouts for all these interactions. Methods add_handler_transient ( handler ) (NoneType) \u2014 Registers a one-time/ad-hoc Pyrogram Handler that is only valid during the context manager body. </> clear_chat ( ) \u2014 Deletes all messages in the conversation with the assigned peer . </> initialize ( start_client ) \u2014 Fetches and caches information about the given peer and optionally starts the assigned client . This method will automatically be called when coroutines of this class are invoked, but you can call it manually to override defaults (namely whether to start_client ). </> query_inline ( query , latitude , longitude , limit ) ( InlineResultContainer ) \u2014 Requests inline results from the peer (which needs to be a bot). </> send_command ( command , args , peer , add_bot_name ) (Message) \u2014 Send a slash-command with corresponding parameters. </> method initialize ( start_client=True ) </> Fetches and caches information about the given peer and optionally starts the assigned client . This method will automatically be called when coroutines of this class are invoked, but you can call it manually to override defaults (namely whether to start_client ). Parameters start_client (bool, optional) \u2014 Set to False if the client should not be started as part of initialization. Note It is unlikely that you will need to call this manually. method clear_chat ( ) </> Deletes all messages in the conversation with the assigned peer . Warning Be careful as this will completely drop your mutual message history. method add_handler_transient ( handler ) </> Registers a one-time/ad-hoc Pyrogram Handler that is only valid during the context manager body. Parameters handler (Handler) \u2014 A Pyrogram Handler (typically a MessageHandler ). Yields (NoneType) None Examples async def some_callback ( client , message ): print ( message ) async def main (): async with controller . add_handler_transient ( MessageHandler ( some_callback , filters . text )): await controller . send_command ( \"start\" ) await asyncio . sleep ( 3 ) # Wait 3 seconds for a reply method collect ( filters=None , count=None , peer=None , max_wait=15 , wait_consecutive=None , raise_=None ) \u2192 abstractasynccontextmanager of Response </> method send_command ( command , args=None , peer=None , add_bot_name=True ) \u2192 Message </> Send a slash-command with corresponding parameters. method query_inline ( query , latitude=None , longitude=None , limit=200 ) </> Requests inline results from the peer (which needs to be a bot). Parameters query (str) \u2014 The query text. latitude (float, optional) \u2014 Latitude of a geo point. longitude (float, optional) \u2014 Longitude of a geo point. limit (int, optional) \u2014 When result pages get iterated automatically, specifies the maximum number of results to return from the bot. Returns ( InlineResultContainer ) A container for convenient access to the inline results.","title":"tgintegration.botcontroller"},{"location":"api/tgintegration.botcontroller/#tgintegrationbotcontroller","text":"</> Entry point to tgintegration features. Classes BotController \u2014 This class is the entry point for all interactions with either regular bots or userbots in TgIntegration . It expects a Pyrogram Client (typically a user client ) that serves as the controll ing account for a specific peer - which can be seen as the \"bot under test\" or \"conversation partner\". In addition, the controller holds a number of settings to control the timeouts for all these interactions. </> class","title":"tgintegration.botcontroller"},{"location":"api/tgintegration.botcontroller/#tgintegrationbotcontrollerbotcontroller","text":"</> This class is the entry point for all interactions with either regular bots or userbots in TgIntegration . It expects a Pyrogram Client (typically a user client ) that serves as the controll ing account for a specific peer - which can be seen as the \"bot under test\" or \"conversation partner\". In addition, the controller holds a number of settings to control the timeouts for all these interactions. Methods add_handler_transient ( handler ) (NoneType) \u2014 Registers a one-time/ad-hoc Pyrogram Handler that is only valid during the context manager body. </> clear_chat ( ) \u2014 Deletes all messages in the conversation with the assigned peer . </> initialize ( start_client ) \u2014 Fetches and caches information about the given peer and optionally starts the assigned client . This method will automatically be called when coroutines of this class are invoked, but you can call it manually to override defaults (namely whether to start_client ). </> query_inline ( query , latitude , longitude , limit ) ( InlineResultContainer ) \u2014 Requests inline results from the peer (which needs to be a bot). </> send_command ( command , args , peer , add_bot_name ) (Message) \u2014 Send a slash-command with corresponding parameters. </> method","title":"tgintegration.botcontroller.BotController"},{"location":"api/tgintegration.botcontroller/#tgintegrationbotcontrollerbotcontrollerinitialize","text":"</> Fetches and caches information about the given peer and optionally starts the assigned client . This method will automatically be called when coroutines of this class are invoked, but you can call it manually to override defaults (namely whether to start_client ). Parameters start_client (bool, optional) \u2014 Set to False if the client should not be started as part of initialization. Note It is unlikely that you will need to call this manually. method","title":"tgintegration.botcontroller.BotController.initialize"},{"location":"api/tgintegration.botcontroller/#tgintegrationbotcontrollerbotcontrollerclear_chat","text":"</> Deletes all messages in the conversation with the assigned peer . Warning Be careful as this will completely drop your mutual message history. method","title":"tgintegration.botcontroller.BotController.clear_chat"},{"location":"api/tgintegration.botcontroller/#tgintegrationbotcontrollerbotcontrolleradd_handler_transient","text":"</> Registers a one-time/ad-hoc Pyrogram Handler that is only valid during the context manager body. Parameters handler (Handler) \u2014 A Pyrogram Handler (typically a MessageHandler ). Yields (NoneType) None Examples async def some_callback ( client , message ): print ( message ) async def main (): async with controller . add_handler_transient ( MessageHandler ( some_callback , filters . text )): await controller . send_command ( \"start\" ) await asyncio . sleep ( 3 ) # Wait 3 seconds for a reply method","title":"tgintegration.botcontroller.BotController.add_handler_transient"},{"location":"api/tgintegration.botcontroller/#tgintegrationbotcontrollerbotcontrollercollect","text":"</> method","title":"tgintegration.botcontroller.BotController.collect"},{"location":"api/tgintegration.botcontroller/#tgintegrationbotcontrollerbotcontrollersend_command","text":"</> Send a slash-command with corresponding parameters. method","title":"tgintegration.botcontroller.BotController.send_command"},{"location":"api/tgintegration.botcontroller/#tgintegrationbotcontrollerbotcontrollerquery_inline","text":"</> Requests inline results from the peer (which needs to be a bot). Parameters query (str) \u2014 The query text. latitude (float, optional) \u2014 Latitude of a geo point. longitude (float, optional) \u2014 Longitude of a geo point. limit (int, optional) \u2014 When result pages get iterated automatically, specifies the maximum number of results to return from the bot. Returns ( InlineResultContainer ) A container for convenient access to the inline results.","title":"tgintegration.botcontroller.BotController.query_inline"},{"location":"api/tgintegration.collector/","text":"module tgintegration . collector </> Standalone collector utilities.","title":"tgintegration.collector"},{"location":"api/tgintegration.collector/#tgintegrationcollector","text":"</> Standalone collector utilities.","title":"tgintegration.collector"},{"location":"api/tgintegration.containers.inline_keyboard/","text":"module tgintegration.containers . inline_keyboard </> \u200b Classes InlineKeyboard \u2014 Represents an inline keyboard attached to a message in the Telegram UI and allows to click those buttons. </> class tgintegration.containers.inline_keyboard . InlineKeyboard ( controller , chat_id , message_id , button_rows ) </> Represents an inline keyboard attached to a message in the Telegram UI and allows to click those buttons. Methods click ( pattern , index ) (Response) \u2014 Uses find_button with the given pattern or index , clicks the button if found, and waits for the bot to react in the same chat. </> find_button ( pattern , index ) (InlineKeyboardButton, optional) \u2014 Attempts to retrieve a clickable button anywhere in the underlying rows by matching the button captions with the given pattern or its global index . If no button could be found, this method raises NoButtonFound . </> method find_button ( pattern=None , index=None ) </> Attempts to retrieve a clickable button anywhere in the underlying rows by matching the button captions with the given pattern or its global index . If no button could be found, this method raises NoButtonFound . The pattern and index arguments are mutually exclusive. Parameters pattern (pattern, optional) \u2014 The button caption to look for (by re.match ). index (int, optional) \u2014 The index of the button, couting from top left to bottom right and starting at 0. Returns (InlineKeyboardButton, optional) The InlineKeyboardButton if found. method click ( pattern=None , index=None ) </> Uses find_button with the given pattern or index , clicks the button if found, and waits for the bot to react in the same chat. If not button could be found, NoButtonFound will be raised. Parameters pattern (pattern or str, optional) \u2014 The button caption to look for (by re.match ). index (int, optional) \u2014 The index of the button, couting from top left to bottom right and starting at 0. Returns (Response) The bot's Response .","title":"tgintegration.containers.inline_keyboard"},{"location":"api/tgintegration.containers.inline_keyboard/#tgintegrationcontainersinline_keyboard","text":"</> \u200b Classes InlineKeyboard \u2014 Represents an inline keyboard attached to a message in the Telegram UI and allows to click those buttons. </> class","title":"tgintegration.containers.inline_keyboard"},{"location":"api/tgintegration.containers.inline_keyboard/#tgintegrationcontainersinline_keyboardinlinekeyboard","text":"</> Represents an inline keyboard attached to a message in the Telegram UI and allows to click those buttons. Methods click ( pattern , index ) (Response) \u2014 Uses find_button with the given pattern or index , clicks the button if found, and waits for the bot to react in the same chat. </> find_button ( pattern , index ) (InlineKeyboardButton, optional) \u2014 Attempts to retrieve a clickable button anywhere in the underlying rows by matching the button captions with the given pattern or its global index . If no button could be found, this method raises NoButtonFound . </> method","title":"tgintegration.containers.inline_keyboard.InlineKeyboard"},{"location":"api/tgintegration.containers.inline_keyboard/#tgintegrationcontainersinline_keyboardinlinekeyboardfind_button","text":"</> Attempts to retrieve a clickable button anywhere in the underlying rows by matching the button captions with the given pattern or its global index . If no button could be found, this method raises NoButtonFound . The pattern and index arguments are mutually exclusive. Parameters pattern (pattern, optional) \u2014 The button caption to look for (by re.match ). index (int, optional) \u2014 The index of the button, couting from top left to bottom right and starting at 0. Returns (InlineKeyboardButton, optional) The InlineKeyboardButton if found. method","title":"tgintegration.containers.inline_keyboard.InlineKeyboard.find_button"},{"location":"api/tgintegration.containers.inline_keyboard/#tgintegrationcontainersinline_keyboardinlinekeyboardclick","text":"</> Uses find_button with the given pattern or index , clicks the button if found, and waits for the bot to react in the same chat. If not button could be found, NoButtonFound will be raised. Parameters pattern (pattern or str, optional) \u2014 The button caption to look for (by re.match ). index (int, optional) \u2014 The index of the button, couting from top left to bottom right and starting at 0. Returns (Response) The bot's Response .","title":"tgintegration.containers.inline_keyboard.InlineKeyboard.click"},{"location":"api/tgintegration.containers/","text":"package tgintegration . containers </> Containers are abstractions that group together Pyrogram types for more convenient access. module tgintegration.containers . responses </> \u200b Classes InvalidResponseError \u2014 Raised when peer's response did not match the expectation . </> module tgintegration.containers . reply_keyboard </> \u200b Classes ReplyKeyboard \u2014 Represents a regular keyboard in the Telegram UI and allows to click buttons in the menu. </> module tgintegration.containers . inline_keyboard </> \u200b Classes InlineKeyboard \u2014 Represents an inline keyboard attached to a message in the Telegram UI and allows to click those buttons. </>","title":"tgintegration.containers"},{"location":"api/tgintegration.containers/#tgintegrationcontainers","text":"</> Containers are abstractions that group together Pyrogram types for more convenient access. module","title":"tgintegration.containers"},{"location":"api/tgintegration.containers/#tgintegrationcontainersresponses","text":"</> \u200b Classes InvalidResponseError \u2014 Raised when peer's response did not match the expectation . </> module","title":"tgintegration.containers.responses"},{"location":"api/tgintegration.containers/#tgintegrationcontainersreply_keyboard","text":"</> \u200b Classes ReplyKeyboard \u2014 Represents a regular keyboard in the Telegram UI and allows to click buttons in the menu. </> module","title":"tgintegration.containers.reply_keyboard"},{"location":"api/tgintegration.containers/#tgintegrationcontainersinline_keyboard","text":"</> \u200b Classes InlineKeyboard \u2014 Represents an inline keyboard attached to a message in the Telegram UI and allows to click those buttons. </>","title":"tgintegration.containers.inline_keyboard"},{"location":"api/tgintegration.containers.reply_keyboard/","text":"module tgintegration.containers . reply_keyboard </> \u200b Classes ReplyKeyboard \u2014 Represents a regular keyboard in the Telegram UI and allows to click buttons in the menu. </> class tgintegration.containers.reply_keyboard . ReplyKeyboard ( controller , chat_id , message_id , button_rows ) </> Represents a regular keyboard in the Telegram UI and allows to click buttons in the menu. Attributes num_buttons (int) \u2014 Returns the total number of buttons in all underlying rows. </> See Also InlineKeyboard Methods click ( pattern , filters , quote ) (Response) \u2014 Uses find_button with the given pattern , clicks the button if found, and waits for the bot to react. For a ReplyKeyboard , this means that a message with the button's caption will be sent to the same chat. </> find_button ( pattern ) (KeyboardButton) \u2014 Attempts to retrieve a clickable button anywhere in the underlying rows by matching the button captions with the given pattern . If no button could be found, this method raises NoButtonFound . </> method find_button ( pattern ) </> Attempts to retrieve a clickable button anywhere in the underlying rows by matching the button captions with the given pattern . If no button could be found, this method raises NoButtonFound . Parameters pattern (pattern) \u2014 The button caption to look for (by re.match ). Returns (KeyboardButton) The KeyboardButton if found. method click ( pattern , filters=None , quote=False ) </> Uses find_button with the given pattern , clicks the button if found, and waits for the bot to react. For a ReplyKeyboard , this means that a message with the button's caption will be sent to the same chat. If not button could be found, NoButtonFound will be raised. Parameters pattern (pattern) \u2014 The button caption to look for (by re.match ). filters (Filter, optional) \u2014 Additional filters to be given to collect . Will be merged with a \"same chat\" filter and filters.text | filters.edited . quote (bool, optional) \u2014 Whether to reply to the message containing the buttons. Returns (Response) The bot's Response .","title":"tgintegration.containers.reply_keyboard"},{"location":"api/tgintegration.containers.reply_keyboard/#tgintegrationcontainersreply_keyboard","text":"</> \u200b Classes ReplyKeyboard \u2014 Represents a regular keyboard in the Telegram UI and allows to click buttons in the menu. </> class","title":"tgintegration.containers.reply_keyboard"},{"location":"api/tgintegration.containers.reply_keyboard/#tgintegrationcontainersreply_keyboardreplykeyboard","text":"</> Represents a regular keyboard in the Telegram UI and allows to click buttons in the menu. Attributes num_buttons (int) \u2014 Returns the total number of buttons in all underlying rows. </> See Also InlineKeyboard Methods click ( pattern , filters , quote ) (Response) \u2014 Uses find_button with the given pattern , clicks the button if found, and waits for the bot to react. For a ReplyKeyboard , this means that a message with the button's caption will be sent to the same chat. </> find_button ( pattern ) (KeyboardButton) \u2014 Attempts to retrieve a clickable button anywhere in the underlying rows by matching the button captions with the given pattern . If no button could be found, this method raises NoButtonFound . </> method","title":"tgintegration.containers.reply_keyboard.ReplyKeyboard"},{"location":"api/tgintegration.containers.reply_keyboard/#tgintegrationcontainersreply_keyboardreplykeyboardfind_button","text":"</> Attempts to retrieve a clickable button anywhere in the underlying rows by matching the button captions with the given pattern . If no button could be found, this method raises NoButtonFound . Parameters pattern (pattern) \u2014 The button caption to look for (by re.match ). Returns (KeyboardButton) The KeyboardButton if found. method","title":"tgintegration.containers.reply_keyboard.ReplyKeyboard.find_button"},{"location":"api/tgintegration.containers.reply_keyboard/#tgintegrationcontainersreply_keyboardreplykeyboardclick","text":"</> Uses find_button with the given pattern , clicks the button if found, and waits for the bot to react. For a ReplyKeyboard , this means that a message with the button's caption will be sent to the same chat. If not button could be found, NoButtonFound will be raised. Parameters pattern (pattern) \u2014 The button caption to look for (by re.match ). filters (Filter, optional) \u2014 Additional filters to be given to collect . Will be merged with a \"same chat\" filter and filters.text | filters.edited . quote (bool, optional) \u2014 Whether to reply to the message containing the buttons. Returns (Response) The bot's Response .","title":"tgintegration.containers.reply_keyboard.ReplyKeyboard.click"},{"location":"api/tgintegration.containers.responses/","text":"module tgintegration.containers . responses </> \u200b Classes InvalidResponseError \u2014 Raised when peer's response did not match the expectation . </> class tgintegration.containers.responses . InvalidResponseError ( ) </> Bases Exception BaseException Raised when peer's response did not match the expectation .","title":"tgintegration.containers.responses"},{"location":"api/tgintegration.containers.responses/#tgintegrationcontainersresponses","text":"</> \u200b Classes InvalidResponseError \u2014 Raised when peer's response did not match the expectation . </> class","title":"tgintegration.containers.responses"},{"location":"api/tgintegration.containers.responses/#tgintegrationcontainersresponsesinvalidresponseerror","text":"</> Bases Exception BaseException Raised when peer's response did not match the expectation .","title":"tgintegration.containers.responses.InvalidResponseError"},{"location":"api/tgintegration.expectation/","text":"module tgintegration . expectation </> \u200b Classes Expectation \u2014 Defines the expected reaction of a peer. </> dataclass tgintegration.expectation . Expectation ( min_messages=<class 'tgintegration.utils.sentinel.NotSet'> , max_messages=<class 'tgintegration.utils.sentinel.NotSet'> ) </> Defines the expected reaction of a peer.","title":"tgintegration.expectation"},{"location":"api/tgintegration.expectation/#tgintegrationexpectation","text":"</> \u200b Classes Expectation \u2014 Defines the expected reaction of a peer. </> dataclass","title":"tgintegration.expectation"},{"location":"api/tgintegration.expectation/#tgintegrationexpectationexpectation","text":"</> Defines the expected reaction of a peer.","title":"tgintegration.expectation.Expectation"},{"location":"api/tgintegration/","text":"package tgintegration </> The root package of tgintegration . module tgintegration . collector </> Standalone collector utilities. package tgintegration . containers </> Containers are abstractions that group together Pyrogram types for more convenient access. module tgintegration . botcontroller </> Entry point to tgintegration features. Classes BotController \u2014 This class is the entry point for all interactions with either regular bots or userbots in TgIntegration . It expects a Pyrogram Client (typically a user client ) that serves as the controll ing account for a specific peer - which can be seen as the \"bot under test\" or \"conversation partner\". In addition, the controller holds a number of settings to control the timeouts for all these interactions. </> module tgintegration . expectation </> \u200b Classes Expectation \u2014 Defines the expected reaction of a peer. </>","title":"tgintegration"},{"location":"api/tgintegration/#tgintegration","text":"</> The root package of tgintegration . module","title":"tgintegration"},{"location":"api/tgintegration/#tgintegrationcollector","text":"</> Standalone collector utilities. package","title":"tgintegration.collector"},{"location":"api/tgintegration/#tgintegrationcontainers","text":"</> Containers are abstractions that group together Pyrogram types for more convenient access. module","title":"tgintegration.containers"},{"location":"api/tgintegration/#tgintegrationbotcontroller","text":"</> Entry point to tgintegration features. Classes BotController \u2014 This class is the entry point for all interactions with either regular bots or userbots in TgIntegration . It expects a Pyrogram Client (typically a user client ) that serves as the controll ing account for a specific peer - which can be seen as the \"bot under test\" or \"conversation partner\". In addition, the controller holds a number of settings to control the timeouts for all these interactions. </> module","title":"tgintegration.botcontroller"},{"location":"api/tgintegration/#tgintegrationexpectation","text":"</> \u200b Classes Expectation \u2014 Defines the expected reaction of a peer. </>","title":"tgintegration.expectation"},{"location":"api/source/tgintegration.botcontroller/","text":"SOURCE CODE tgintegration. botcontroller DOCS \"\"\" Entry point to {{tgi}} features. \"\"\" import asyncio import logging from contextlib import asynccontextmanager from time import time from typing import AsyncGenerator from typing import cast from typing import List from typing import Optional from typing import Union from pyrogram import Client from pyrogram import filters from pyrogram.errors import FloodWait from pyrogram.filters import Filter from pyrogram.handlers.handler import Handler from pyrogram.raw.base import BotCommand from pyrogram.raw.functions.messages import DeleteHistory from pyrogram.raw.functions.users import GetFullUser from pyrogram.raw.types import BotInfo from pyrogram.raw.types import InputPeerUser from pyrogram.raw.types.messages import BotResults from pyrogram.types import Message from pyrogram.types import User from typing_extensions import AsyncContextManager from tgintegration.collector import collect from tgintegration.containers.inlineresults import InlineResult from tgintegration.containers.inlineresults import InlineResultContainer from tgintegration.containers.responses import Response from tgintegration.expectation import Expectation from tgintegration.handler_utils import add_handler_transient from tgintegration.timeout_settings import TimeoutSettings from tgintegration.utils.frame_utils import get_caller_function_name from tgintegration.utils.sentinel import NotSet class BotController : DOCS \"\"\" This class is the entry point for all interactions with either regular bots or userbots in `TgIntegration`. It expects a Pyrogram `Client` (typically a **user client**) that serves as the controll**ing** account for a specific `peer` - which can be seen as the \"bot under test\" or \"conversation partner\". In addition, the controller holds a number of settings to control the timeouts for all these interactions. \"\"\" def __init__ ( self , client : Client , peer : Union [ int , str ], * , max_wait : Union [ int , float ] = 20.0 , wait_consecutive : Optional [ Union [ int , float ]] = 2.0 , raise_no_response : bool = True , global_action_delay : Union [ int , float ] = 0.8 , ): \"\"\" Creates a new `BotController`. Args: client: A Pyrogram user client that acts as the controll*ing* account. peer: The bot under test or conversation partner. max_wait: Maximum time in seconds for the `peer` to produce the expected response. wait_consecutive: Additional time in seconds to wait for _additional_ messages upon receiving a response (even when `max_wait` is exceeded). raise_no_response: Whether to raise an exception on timeout/invalid response or to log silently. global_action_delay: The time to wait in between `collect` calls. \"\"\" self . client = client self . peer = peer self . max_wait_response = max_wait self . min_wait_consecutive = wait_consecutive self . raise_no_response = raise_no_response self . global_action_delay = global_action_delay self . _input_peer : Optional [ InputPeerUser ] = None self . peer_user : Optional [ User ] = None self . peer_id : Optional [ int ] = None self . command_list : List [ BotCommand ] = [] self . _last_response_ts : Optional [ time ] = None self . logger = logging . getLogger ( self . __class__ . __name__ ) async def initialize ( self , start_client : bool = True ) -> None : DOCS # noinspection PyUnresolvedReferences \"\"\" Fetches and caches information about the given `peer` and optionally starts the assigned `client`. This method will automatically be called when coroutines of this class are invoked, but you can call it manually to override defaults (namely whether to `start_client`). Args: start_client: Set to `False` if the client should not be started as part of initialization. !!! note It is unlikely that you will need to call this manually. \"\"\" if start_client and not self . client . is_connected : await self . client . start () self . _input_peer = await self . client . resolve_peer ( self . peer ) self . peer_user = await self . client . get_users ( self . peer ) self . peer_id = self . peer_user . id if self . peer_user . is_bot : self . command_list = await self . _get_command_list () async def _ensure_preconditions ( self , * , bots_only : bool = False ): if not self . peer_id : await self . initialize () if bots_only and not self . peer_user . is_bot : caller = get_caller_function_name () raise ValueError ( f \"This controller is assigned to a user peer, but ' { caller } ' can only be used with a bot.\" ) def _merge_default_filters ( self , user_filters : Filter = None , override_peer : Union [ int , str ] = None ) -> Filter : chat_filter = filters . chat ( override_peer or self . peer_id ) & filters . incoming if user_filters is None : return chat_filter else : return user_filters & chat_filter async def _get_command_list ( self ) -> List [ BotCommand ]: return list ( cast ( BotInfo , ( await self . client . send ( GetFullUser ( id = await self . client . resolve_peer ( self . peer_id )) ) ) . bot_info , ) . commands ) async def clear_chat ( self ) -> None : DOCS \"\"\" Deletes all messages in the conversation with the assigned `peer`. !!! warning Be careful as this will completely drop your mutual message history. \"\"\" await self . _ensure_preconditions () await self . client . send ( DeleteHistory ( peer = self . _input_peer , max_id = 0 , just_clear = False ) ) async def _wait_global ( self ): if self . global_action_delay and self . _last_response_ts : # Sleep for as long as the global delay prescribes sleep = self . global_action_delay - ( time () - self . _last_response_ts . started ) if sleep > 0 : await asyncio . sleep ( sleep ) @asynccontextmanager DOCS async def add_handler_transient ( self , handler : Handler ) -> AsyncContextManager [ None ]: \"\"\" Registers a one-time/ad-hoc Pyrogram `Handler` that is only valid during the context manager body. Args: handler: A Pyrogram `Handler` (typically a `MessageHandler`). Yields: `None` Examples: ``` python async def some_callback(client, message): print(message) async def main(): async with controller.add_handler_transient(MessageHandler(some_callback, filters.text)): await controller.send_command(\"start\") await asyncio.sleep(3) # Wait 3 seconds for a reply ``` \"\"\" async with add_handler_transient ( self . client , handler ): yield @asynccontextmanager DOCS async def collect ( self , filters : Filter = None , count : int = None , * , peer : Union [ int , str ] = None , max_wait : Union [ int , float ] = 15 , wait_consecutive : Optional [ Union [ int , float ]] = None , raise_ : Optional [ bool ] = None , ) -> AsyncContextManager [ Response ]: \"\"\" Args: filters (): count (): peer (): max_wait (): wait_consecutive (): raise_ (): Returns: \"\"\" await self . _ensure_preconditions () await self . _wait_if_necessary () async with collect ( self , self . _merge_default_filters ( filters , peer ), expectation = Expectation ( min_messages = count or NotSet , max_messages = count or NotSet ), timeouts = TimeoutSettings ( max_wait = max_wait , wait_consecutive = wait_consecutive , raise_on_timeout = raise_ if raise_ is not None else self . raise_no_response , ), ) as response : yield response self . _last_response_ts = response . last_message_timestamp async def _wait_if_necessary ( self ): if not self . global_action_delay or not self . _last_response_ts : return wait_for = ( self . global_action_delay + self . _last_response_ts ) - time () if wait_for > 0 : # noinspection PyUnboundLocalVariable self . logger . debug ( f \"Waiting { wait_for } seconds due to global action delay...\" ) await asyncio . sleep ( wait_for ) async def ping_bot ( self , override_messages : List [ str ] = None , override_filters : Filter = None , * , peer : Union [ int , str ] = None , max_wait : Union [ int , float ] = 15 , wait_consecutive : Optional [ Union [ int , float ]] = None , ) -> Response : await self . _ensure_preconditions () peer = peer or self . peer_id messages = [ \"/start\" ] if override_messages : messages = override_messages async def send_pings (): for n , m in enumerate ( messages ): try : if n >= 1 : await asyncio . sleep ( 1 ) await self . send_command ( m , peer = peer ) except FloodWait as e : if e . x > 5 : self . logger . warning ( \"send_message flood: waiting {} seconds\" . format ( e . x ) ) await asyncio . sleep ( e . x ) continue async with collect ( self , self . _merge_default_filters ( override_filters , peer ), expectation = Expectation ( min_messages = 1 ), timeouts = TimeoutSettings ( max_wait = max_wait , wait_consecutive = wait_consecutive ), ) as response : await send_pings () return response async def send_command ( DOCS self , command : str , args : List [ str ] = None , peer : Union [ int , str ] = None , add_bot_name : bool = True , ) -> Message : \"\"\" Send a slash-command with corresponding parameters. \"\"\" text = \"/\" + command . lstrip ( \"/\" ) if add_bot_name and self . peer_user . username : text += f \"@ { self . peer_user . username } \" if args : text += \" \" text += \" \" . join ( args ) return await self . client . send_message ( peer or self . peer_id , text ) async def _iter_bot_results ( self , bot_results : BotResults , query : str , latitude : float = None , longitude : float = None , limit : int = 200 , current_offset : str = \"\" , ) -> AsyncGenerator [ InlineResult , None ]: num_returned : int = 0 while num_returned <= limit : for result in bot_results . results : yield InlineResult ( self , result , bot_results . query_id ) num_returned += 1 if not bot_results . next_offset or current_offset == bot_results . next_offset : break # no more results bot_results : BotResults = await self . client . get_inline_bot_results ( self . peer_id , query , offset = current_offset , latitude = latitude , longitude = longitude , ) current_offset = bot_results . next_offset async def query_inline ( DOCS self , query : str , latitude : float = None , longitude : float = None , limit : int = 200 , ) -> InlineResultContainer : \"\"\" Requests inline results from the `peer` (which needs to be a bot). Args: query: The query text. latitude: Latitude of a geo point. longitude: Longitude of a geo point. limit: When result pages get iterated automatically, specifies the maximum number of results to return from the bot. Returns: A container for convenient access to the inline results. \"\"\" await self . _ensure_preconditions ( bots_only = True ) if limit <= 0 : raise ValueError ( \"Cannot get 0 or less results.\" ) start_offset = \"\" first_batch : BotResults = await self . client . get_inline_bot_results ( self . peer_id , query , offset = start_offset , latitude = latitude , longitude = longitude , ) gallery = first_batch . gallery switch_pm = first_batch . switch_pm users = first_batch . users results = [ x async for x in self . _iter_bot_results ( first_batch , query , latitude = latitude , longitude = longitude , limit = limit , current_offset = start_offset , ) ] return InlineResultContainer ( self , query , latitude = latitude , longitude = longitude , results = results , gallery = gallery , switch_pm = switch_pm , users = users , )","title":"tgintegration.botcontroller"},{"location":"api/source/tgintegration.collector/","text":"SOURCE CODE tgintegration. collector DOCS \"\"\" Standalone `collector` utilities. \"\"\" import asyncio import logging from contextlib import asynccontextmanager from datetime import datetime from datetime import timedelta from typing import AsyncContextManager from typing import TYPE_CHECKING from pyrogram.errors import InternalServerError from pyrogram.filters import Filter from pyrogram.handlers import MessageHandler from tgintegration.expectation import Expectation from tgintegration.handler_utils import add_handler_transient from tgintegration.timeout_settings import TimeoutSettings if TYPE_CHECKING : from tgintegration.botcontroller import BotController from tgintegration.containers.responses import InvalidResponseError , Response from tgintegration.update_recorder import MessageRecorder logger = logging . getLogger ( __name__ ) @asynccontextmanager async def collect ( controller : \"BotController\" , filters : Filter = None , expectation : Expectation = None , timeouts : TimeoutSettings = None , ) -> AsyncContextManager [ Response ]: expectation = expectation or Expectation () timeouts = timeouts or TimeoutSettings () recorder = MessageRecorder () handler = MessageHandler ( recorder . record_message , filters = filters ) assert controller . client . is_connected async with add_handler_transient ( controller . client , handler ): response = Response ( controller , recorder ) logger . debug ( \"Collector set up. Executing user-defined interaction...\" ) yield response # Start user-defined interaction logger . debug ( \"interaction complete.\" ) num_received = 0 # last_received_timestamp = ( # None # TODO: work with the message's timestamp instead of utcnow() # ) timeout_end = datetime . utcnow () + timedelta ( seconds = timeouts . max_wait ) try : seconds_remaining = ( timeout_end - datetime . utcnow ()) . total_seconds () while True : if seconds_remaining > 0 : # Wait until we receive any message or time out logger . debug ( f \"Waiting for message # { num_received + 1 } \" ) await asyncio . wait_for ( recorder . wait_until ( lambda msgs : expectation . is_sufficient ( msgs ) or len ( msgs ) > num_received ), timeout = seconds_remaining , ) num_received = len ( recorder . messages ) # TODO: this is ugly if timeouts . wait_consecutive : # Always wait for at least `wait_consecutive` seconds for another message try : logger . debug ( f \"Checking for consecutive message to # { num_received } ...\" ) await asyncio . wait_for ( recorder . wait_until ( lambda msgs : len ( msgs ) > num_received ), # The consecutive end may go over the max wait timeout, # which is a design decision. timeout = timeouts . wait_consecutive , ) logger . debug ( \"received 1.\" ) except TimeoutError : logger . debug ( \"none received.\" ) num_received = len ( recorder . messages ) # TODO: this is ugly is_sufficient = expectation . is_sufficient ( recorder . messages ) if is_sufficient : expectation . verify ( recorder . messages , timeouts ) return seconds_remaining = ( timeout_end - datetime . utcnow ()) . total_seconds () assert seconds_remaining is not None if seconds_remaining <= 0 : expectation . verify ( recorder . messages , timeouts ) return except InternalServerError as e : logger . warning ( e ) await asyncio . sleep ( 60 ) # Internal Telegram error except asyncio . exceptions . TimeoutError as te : if timeouts . raise_on_timeout : raise InvalidResponseError () from te else : # TODO: better warning message logger . warning ( \"Peer did not reply.\" ) finally : recorder . stop ()","title":"tgintegration.collector"},{"location":"api/source/tgintegration.containers.inline_keyboard/","text":"SOURCE CODE tgintegration.containers. inline_keyboard DOCS \"\"\" \u200b \"\"\" import itertools import re from typing import List from typing import Optional from typing import Pattern from typing import TYPE_CHECKING from typing import Union from pyrogram import filters as f from pyrogram.types import InlineKeyboardButton from tgintegration.containers.exceptions import NoButtonFound if TYPE_CHECKING : from tgintegration.botcontroller import BotController from tgintegration.containers.responses import Response class InlineKeyboard : DOCS \"\"\" Represents an inline keyboard attached to a message in the Telegram UI and allows to click those buttons. \"\"\" def __init__ ( self , controller : \"BotController\" , chat_id : Union [ int , str ], message_id : int , button_rows : List [ List [ InlineKeyboardButton ]], ): self . _controller = controller self . _message_id = message_id self . _peer_id = chat_id self . rows = button_rows def find_button ( DOCS self , pattern : Pattern = None , index : int = None ) -> Optional [ InlineKeyboardButton ]: \"\"\" Attempts to retrieve a clickable button anywhere in the underlying `rows` by matching the button captions with the given `pattern` or its global `index`. If no button could be found, **this method raises** `NoButtonFound`. The `pattern` and `index` arguments are mutually exclusive. Args: pattern: The button caption to look for (by `re.match`). index: The index of the button, couting from top left to bottom right and starting at 0. Returns: The `InlineKeyboardButton` if found. \"\"\" index_set = index or index == 0 if not any (( pattern , index_set )) or all (( pattern , index_set )): raise ValueError ( \"Exactly one of the `pattern` or `index` arguments must be provided.\" ) if pattern : compiled = re . compile ( pattern ) for row in self . rows : for button in row : if compiled . match ( button . text ): return button raise NoButtonFound elif index_set : try : buttons_flattened = list ( itertools . chain . from_iterable ( self . rows )) if index < 0 : index += len ( buttons_flattened ) return next ( itertools . islice ( buttons_flattened , index , index + 1 )) except ( StopIteration , ValueError ): raise NoButtonFound async def click ( DOCS self , pattern : Union [ Pattern , str ] = None , index : Optional [ int ] = None , ) -> \"Response\" : \"\"\" Uses `find_button` with the given `pattern` or `index`, clicks the button if found, and waits for the bot to react in the same chat. If not button could be found, `NoButtonFound` will be raised. Args: pattern: The button caption to look for (by `re.match`). index: The index of the button, couting from top left to bottom right and starting at 0. Returns: The bot's `Response`. \"\"\" button = self . find_button ( pattern , index ) async with self . _controller . collect ( filters = f . chat ( self . _peer_id ) ) as res : # type: Response await self . _controller . client . request_callback_answer ( chat_id = self . _peer_id , message_id = self . _message_id , callback_data = button . callback_data , ) return res def __eq__ ( self , other ): if not isinstance ( other , InlineKeyboard ): return False try : for r_n , row in enumerate ( self . rows ): other_row = other . rows [ r_n ] for b_n , btn in enumerate ( row ): other_btn = other_row [ b_n ] if ( btn . text != other_btn . text or btn . switch_inline_query_current_chat != other_btn . switch_inline_query_current_chat or btn . switch_inline_query != other_btn . switch_inline_query or btn . callback_data != other_btn . callback_data or btn . url != other_btn . url ): return False except KeyError : return False return True @property def num_buttons ( self ): return sum ( len ( row ) for row in self . rows )","title":"tgintegration.containers.inline_keyboard"},{"location":"api/source/tgintegration.containers/","text":"SOURCE CODE tgintegration. containers DOCS \"\"\" Containers are abstractions that group together Pyrogram types for more convenient access. \"\"\" from .exceptions import NoButtonFound from .inline_keyboard import InlineKeyboard from .inlineresults import InlineResult from .inlineresults import InlineResultContainer from .reply_keyboard import ReplyKeyboard from .responses import InvalidResponseError from .responses import Response __all__ = [ \"InlineResultContainer\" , \"InlineResult\" , \"Response\" , \"InvalidResponseError\" , \"NoButtonFound\" , \"InlineKeyboard\" , \"ReplyKeyboard\" , ]","title":"tgintegration.containers"},{"location":"api/source/tgintegration.containers.reply_keyboard/","text":"SOURCE CODE tgintegration.containers. reply_keyboard DOCS \"\"\" \u200b \"\"\" import re from typing import List from typing import Pattern from typing import TYPE_CHECKING from typing import Union from pyrogram import filters as f from pyrogram.filters import Filter from pyrogram.types import KeyboardButton from pyrogram.types import Message from tgintegration.containers import NoButtonFound if TYPE_CHECKING : from tgintegration.botcontroller import BotController from tgintegration.containers.responses import Response class ReplyKeyboard : DOCS \"\"\" Represents a regular keyboard in the Telegram UI and allows to click buttons in the menu. See Also: [InlineKeyboard](tgintegration.InlineKeyboard) \"\"\" def __init__ ( self , controller : \"BotController\" , chat_id : Union [ int , str ], message_id : int , button_rows : List [ List [ KeyboardButton ]], ): self . _controller : BotController = controller self . _message_id = message_id self . _peer_id = chat_id self . rows = button_rows def find_button ( self , pattern : Pattern ) -> KeyboardButton : DOCS \"\"\" Attempts to retrieve a clickable button anywhere in the underlying `rows` by matching the button captions with the given `pattern`. If no button could be found, **this method raises** `NoButtonFound`. Args: pattern: The button caption to look for (by `re.match`). Returns: The `KeyboardButton` if found. \"\"\" compiled = re . compile ( pattern ) for row in self . rows : for button in row : # TODO: Investigate why sometimes it's a button and other times a string if compiled . match ( button . text if hasattr ( button , \"text\" ) else button ): return button raise NoButtonFound ( f \"No clickable entity found for pattern r' { pattern } '\" ) async def _click_nowait ( self , pattern , quote = False ) -> Message : button = self . find_button ( pattern ) return await self . _controller . client . send_message ( self . _peer_id , button . text , reply_to_message_id = self . _message_id if quote else None , ) @property DOCS def num_buttons ( self ) -> int : \"\"\" Returns the total number of buttons in all underlying rows. \"\"\" return sum ( len ( row ) for row in self . rows ) async def click ( DOCS self , pattern : Pattern , filters : Filter = None , quote : bool = False ) -> \"Response\" : \"\"\" Uses `find_button` with the given `pattern`, clicks the button if found, and waits for the bot to react. For a `ReplyKeyboard`, this means that a message with the button's caption will be sent to the same chat. If not button could be found, `NoButtonFound` will be raised. Args: pattern: The button caption to look for (by `re.match`). filters: Additional filters to be given to `collect`. Will be merged with a \"same chat\" filter and `filters.text | filters.edited`. quote: Whether to reply to the message containing the buttons. Returns: The bot's `Response`. \"\"\" button = self . find_button ( pattern ) filters = ( filters & f . chat ( self . _peer_id ) if filters else f . chat ( self . _peer_id ) ) & ( f . text | f . edited ) async with self . _controller . collect ( filters = filters ) as res : # type: Response await self . _controller . client . send_message ( self . _controller . peer , button . text if hasattr ( button , \"text\" ) else button , reply_to_message_id = self . _message_id if quote else None , ) return res","title":"tgintegration.containers.reply_keyboard"},{"location":"api/source/tgintegration.containers.responses/","text":"SOURCE CODE tgintegration.containers. responses DOCS \"\"\" \u200b \"\"\" from datetime import datetime from time import time from typing import Any from typing import List from typing import Optional from typing import Set from typing import TYPE_CHECKING from pyrogram.types import InlineKeyboardMarkup from pyrogram.types import Message from pyrogram.types import ReplyKeyboardMarkup from tgintegration.containers import InlineKeyboard from tgintegration.containers import ReplyKeyboard from tgintegration.update_recorder import MessageRecorder if TYPE_CHECKING : from tgintegration.botcontroller import BotController class Response : def __init__ ( self , controller : \"BotController\" , recorder : MessageRecorder ): self . _controller = controller self . _recorder = recorder self . started : Optional [ float ] = None self . action_result : Any = None # cached properties self . __reply_keyboard : Optional [ ReplyKeyboard ] = None self . __inline_keyboards : List [ InlineKeyboard ] = [] @property def messages ( self ) -> List [ Message ]: return self . _recorder . messages @property def is_empty ( self ) -> bool : return not self . messages @property def num_messages ( self ) -> int : return len ( self . messages ) @property def full_text ( self ) -> str : return \" \\n \" . join ( x . text for x in self . messages if x . text ) or \"\" @property def reply_keyboard ( self ) -> Optional [ ReplyKeyboard ]: if self . __reply_keyboard : return self . __reply_keyboard if self . is_empty : return None # Contingent upon the way Telegram works, # only the *last* message with buttons in a response object matters messages = reversed ( self . messages ) for m in messages : if isinstance ( m . reply_markup , ReplyKeyboardMarkup ): last_kb_msg = m break else : return None # No message with a keyboard found reply_keyboard = ReplyKeyboard ( controller = self . _controller , chat_id = last_kb_msg . chat . id , message_id = last_kb_msg . message_id , button_rows = last_kb_msg . reply_markup . keyboard , ) self . __reply_keyboard = reply_keyboard return reply_keyboard @property def inline_keyboards ( self ) -> Optional [ List [ InlineKeyboard ]]: if self . __inline_keyboards : return self . __inline_keyboards if self . is_empty : return None inline_keyboards = [ InlineKeyboard ( controller = self . _controller , chat_id = message . chat . id , message_id = message . message_id , button_rows = message . reply_markup . inline_keyboard , ) for message in self . messages if isinstance ( message . reply_markup , InlineKeyboardMarkup ) ] self . __inline_keyboards = inline_keyboards return inline_keyboards @property def keyboard_buttons ( self ) -> Set [ str ]: all_buttons = set () for m in self . messages : markup = m . reply_markup if markup and hasattr ( markup , \"keyboard\" ): for row in markup . keyboard : for button in row : all_buttons . add ( button ) return all_buttons @property def last_message_datetime ( self ) -> Optional [ datetime ]: if self . is_empty : return None return datetime . fromtimestamp ( self . messages [ - 1 ] . date ) @property def last_message_timestamp ( self ) -> Optional [ time ]: if self . is_empty : return None return self . messages [ - 1 ] . date @property def commands ( self ) -> Set [ str ]: all_commands = set () for m in self . messages : entity_commands = [ x for x in m . entities if x . type == \"bot_command\" ] for e in entity_commands : all_commands . add ( m . text [ e . offset , len ( m . text ) - e . length ]) caption_entity_commands = [ x for x in m . entities if x . type == \"bot_command\" ] for e in caption_entity_commands : all_commands . add ( m . caption [ e . offset , len ( m . caption ) - e . length ]) return all_commands async def delete_all_messages ( self , revoke : bool = True ): peer_id = self . messages [ 0 ] . chat . id await self . _controller . client . delete_messages ( peer_id , [ x . message_id for x in self . messages ], revoke = revoke ) def __eq__ ( self , other ): if not isinstance ( other , Response ): return False return ( self . full_text == other . full_text and self . inline_keyboards == other . inline_keyboards # TODO: self.keyboard == other.keyboard ) def __getitem__ ( self , item ): return self . messages [ item ] def __str__ ( self ): if self . is_empty : return \"Empty response\" return \" \\n then \\n \" . join ([ '\" {} \"' . format ( m . text ) for m in self . messages ]) class InvalidResponseError ( Exception ): DOCS \"\"\" Raised when peer's response did not match the [expectation](tgintegration.expectation.Expectation). \"\"\"","title":"tgintegration.containers.responses"},{"location":"api/source/tgintegration.expectation/","text":"SOURCE CODE tgintegration. expectation DOCS \"\"\" \u200b \"\"\" import logging from dataclasses import dataclass from typing import List from typing import Union from pyrogram.types import Message from tgintegration.containers.responses import InvalidResponseError from tgintegration.timeout_settings import TimeoutSettings from tgintegration.utils.sentinel import NotSet logger = logging . getLogger ( __name__ ) @dataclass class Expectation : DOCS \"\"\" Defines the expected reaction of a peer. \"\"\" min_messages : Union [ int , NotSet ] = NotSet \"\"\" Minimum number of expected messages. \"\"\" max_messages : Union [ int , NotSet ] = NotSet \"\"\" Maximum number of expected messages. \"\"\" def is_sufficient ( self , messages : List [ Message ]) -> bool : n = len ( messages ) if self . min_messages is NotSet : return n >= 1 return n >= self . min_messages def _is_match ( self , messages : List [ Message ]) -> bool : n = len ( messages ) return ( self . min_messages is NotSet or n >= self . min_messages ) and ( self . max_messages is NotSet or n <= self . max_messages ) def verify ( self , messages : List [ Message ], timeouts : TimeoutSettings ) -> None : if self . _is_match ( messages ): return n = len ( messages ) if n < self . min_messages : _raise_or_log ( timeouts , \"Expected {} messages but only received {} after waiting {} seconds.\" , self . min_messages , n , timeouts . max_wait , ) return if n > self . max_messages : _raise_or_log ( timeouts , \"Expected only {} messages but received {} .\" , self . max_messages , n , ) return def _raise_or_log ( timeouts : TimeoutSettings , msg : str , * fmt ) -> None : if timeouts . raise_on_timeout : if fmt : raise InvalidResponseError ( msg . format ( * fmt )) else : raise InvalidResponseError ( msg ) logger . debug ( msg , * fmt )","title":"tgintegration.expectation"},{"location":"api/source/tgintegration/","text":"SOURCE CODE tgintegration DOCS # -*- coding: utf-8 -*- \"\"\" The root package of {{tgi}}. \"\"\" from tgintegration.botcontroller import BotController from tgintegration.containers import InlineKeyboard from tgintegration.containers import InlineResult from tgintegration.containers import InlineResultContainer from tgintegration.containers import InvalidResponseError from tgintegration.containers import ReplyKeyboard from tgintegration.containers import Response __all__ = [ \"Response\" , \"BotController\" , \"InlineResult\" , \"InlineResultContainer\" , \"InvalidResponseError\" , \"InlineKeyboard\" , \"ReplyKeyboard\" , ]","title":"tgintegration"},{"location":"tutorials/testing/","text":"","title":"Testing"}]}